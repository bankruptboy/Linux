book unit1  1-6 查看你的系统的头文件limits.h。系统相关的静态限制值有哪些?它们的值各为多少?特别地，整数类型、浮点类型和双精度类型的最大、最小值各为多少?
              浮点类型的数据在float.h头文件中。并不在limits头文件中。
              带符号char：
              /* Minimum and maximum values a `signed char' can hold.  */
               #  define SCHAR_MIN	(-128)
               #  define SCHAR_MAX	127
               无符号char：
               /* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
               #  define UCHAR_MAX	255
               带符号short：
              /* Minimum and maximum values a `signed short int' can hold.  */
               #  define SHRT_MIN	(-32768)
               #  define SHRT_MAX	32767
               无符号short：
               /* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
               #  define USHRT_MAX	65535
               带符号整型：
              /* Minimum and maximum values a `signed int' can hold.  */
               #  define INT_MIN	(-INT_MAX - 1)
               #  define INT_MAX	2147483647
                无符号整型：
               /* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
               #  define UINT_MAX	4294967295U
               带符号长整型：
               /* Minimum and maximum values a `signed long int' can hold.  */
               #  if __WORDSIZE == 64
               #   define LONG_MAX	9223372036854775807L
               #  else
               #   define LONG_MAX	2147483647L
               #  endif
               #  define LONG_MIN	(-LONG_MAX - 1L)
               无符号长整形：
               /* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
               #  if __WORDSIZE == 64
               #   define ULONG_MAX	18446744073709551615UL
               #  else
               #   define ULONG_MAX	4294967295UL
               #  endif
               带符号长长整型：
               /* Minimum and maximum values a `signed long long int' can hold.  */
               #   define LLONG_MAX	9223372036854775807LL
               #   define LLONG_MIN	(-LLONG_MAX - 1LL)
               无符号长长整型：
               /* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
               #   define ULLONG_MAX	18446744073709551615ULL
		float
		float在32位的情况下，其中1位符号位，8位指数位，23位尾数位
		有效位数 6 ~ 7
		取值范围 -(3.4 * 10 ^ 38) ～ +(3.4 * 10 ^ 38)

		double
		double在64位的情况下，其中1位符号位，11位指数位，52位尾数位
		有效位数 15 ~ 16
		取值范围 -(1.7 * 10 ^ 308) ~ +(1.7 * 10 ^ 308)

		long double
		long double在128位的情况下，其中1位符号位，64位指数位，63位尾数位
		有效位数 18 ~ 19
		取值范围 -(1.2 * 10 ^ 4932) ~ +(1.2 * 10 ^ 4932)



指数的默认进制
FLT_RADIX 默认值是2，表示指数是以2进制表示

尾数的位数
FLT_MANT_DIG 默认值是23，表示float类型的变量尾数的位数是23位
DBL_MANT_DIG 默认值是52，表示double类型的变量尾数的位数是52位
LDBL_MANT_DIG 默认值是63，表示long double类型的变量尾数的位数是63位

小数点后的位数，就是四舍五入后肯定能保证的精度
FLT_DIG 默认值是6，表示float类型的变量小数点后的位数是6位
DBL_DIG 默认值是15，表示double类型的变量小数点后的位数是15位
LDBL_DIG 默认值是18，表示long double类型的变量小数点后的位数是18位

指数的最小整数
FLT_MIN_EXP 默认值是-125
DBL_MIN_EXP 默认值是-1021
LDBL_MIN_EXP 默认值是-16381

指数的最小负整数
FLT_MIN_10_EXP 默认值是-37
DBL_MIN_10_EXP 默认值是-307
LDBL_MIN_10_EXP 默认值是-4931

指数的最大整数
FLT_MAX_EXP 默认值是128
DBL_MAX_EXP 默认值是1024
LDBL_MAX_EXP 默认值是16384

指数的最大非负整数
FLT_MAX_10_EXP 默认值是38
DBL_MAX_10_EXP 默认值是308
LDBL_MAX_10_EXP 默认值是4932

最大值
FLT_MAX 默认值是3.4 * 10 ^ 38
DBL_MAX 默认值是1.7 * 10 ^ 308
LDBL_MAX 默认值是1.2 * 10 ^ 4932

跨度值
FLT_EPSILON 默认值是0
DBL_EPSILON 默认值是0
LDBL_EPSILON 默认值是0

最小的正数
FLT_MIN 默认值是0
DBL_MIN 默认值是0
LDBL_MIN 默认值是0

四舍五入的方式
FLT_ROUNDS，0代表向0，1代表向最近的，2代表向正无穷，3代表向负无穷，-1代表不确定





unit2  2-7 编写程序说明gets()函数的危险性。
     
     
python@ubuntu:~$ vi gets.c
python@ubuntu:~$ gcc gets.c -o gets
gets.c: In function ‘main’:
gets.c:16:5: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration]
     gets(buffer.buf);
     ^
/tmp/cczaow6C.o：在函数‘main’中：
gets.c:(.text+0x58): 警告： the `gets' function is dangerous and should not be used.
python@ubuntu:~$ ./gets
please enter a line
abcdefghijk
gets() get string "abcdefghijk"
buffer.others is "ijk"
python@ubuntu:~$ cat gets.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define BUF_SIZE 8

int main(void)
{
    FILE *fd;
    int fgets_yes;
    struct iobuf {
        char buf[BUF_SIZE];
        char others[BUF_SIZE];
    }buffer;
    memset(&buffer,'\0',sizeof(struct iobuf)); 
    fprintf(stdout,"please enter a line\n");
    gets(buffer.buf);
    fprintf(stdout,"gets() get string \"%s\"\n",buffer.buf);
    /* 查看溢出情况 */
    fprintf(stdout,"buffer.others is \"%s\"\n",buffer.others);
    exit(0);
}


     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
2-10 设某个文件含n个记录，文件的第一个字(4字节）给出记录的总个数n，随后的n个字给出各个记录的长度（字节数)，剩余部分则由各个记录组成。
     编写一个根据文件指针和记录编号（从Ⅰ开始编号）读取第k个记录的函数。
python@ubuntu:~/week5$ vi aaa.c
python@ubuntu:~/week5$ gcc aaa.c -o aaa
python@ubuntu:~/week5$ ./aaa
1
C Pr
python@ubuntu:~/week5$ ./aaa
2
og
python@ubuntu:~/week5$ cat aaa.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
void fun(char *str)
{
	char *str_c=str;
	int i,j=0;
	for(i=0;str[i]!='\0';i++)
	{
		if(str[i]!=' ')
			str_c[j++]=str[i];
	}
	str_c[j]='\0';
	str=str_c;	
}

void findljj(FILE *fp,int i)
{
	char str[60];
	char buffer[20];
	char buf[100];
	int b = 0;//某数前面数据的长度
	//读出数据的个数 
	fseek(fp , 0 ,SEEK_SET);
    fread(buffer, 1, 1, fp);
    
  	int n; //数据个数 
    sscanf(buffer,"%d",&n);    
    
    //读出数据的长度 
	fseek(fp , 4 ,SEEK_SET);
    fread(buf, sizeof(buf), 1, fp);
    fun(buf);
	for(int l = 0;l<i-1;l++)
	{
		b=buf[l]+b-'0';		
	//	printf("%d\n",b);
	}

    //读出第i个数据的内容 
    fseek(fp , (n+1)*4+b ,SEEK_SET);
	if(fgets (str, (int)(buf[i-1]-'0')+1, fp)!=NULL ) {
    	puts(str);
   }
   else{
   	  printf("error");
   }
}
int main ()
{
   FILE *fp;
   fp = fopen("file.txt","w+");
   int i; //第几个数据  
   scanf("%d",&i); 
   //写入数据 
   fputs("2   ", fp);  
   fseek( fp, 0, SEEK_CUR );
   fputs("4   ", fp); 
   fseek(fp , 0 ,SEEK_CUR);
   fputs("2   ", fp);
   fseek(fp , 0 ,SEEK_CUR);
   fputs("C Programming Langauge", fp);
      
   findljj(fp,i);
   fclose(fp);
   
   return 0;
}
